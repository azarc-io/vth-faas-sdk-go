// Package client provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.12.4 DO NOT EDIT.
package client

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// Defines values for CompleteStageType.
const (
	Complete CompleteStageType = "complete"
)

// Defines values for LogLevel.
const (
	LogLevelDebug LogLevel = "debug"
	LogLevelError LogLevel = "error"
	LogLevelInfo  LogLevel = "info"
)

// Defines values for OutputMimetype.
const (
	Applicationjson        OutputMimetype = "application/json"
	ApplicationoctetStream OutputMimetype = "application/octet-stream"
	Applicationtext        OutputMimetype = "application/text"
)

// Defines values for StageType.
const (
	StageTypeStage StageType = "stage"
)

// CompleteStage defines model for completeStage.
type CompleteStage struct {
	Inputs []string          `json:"inputs"`
	Name   string            `json:"name"`
	Type   CompleteStageType `json:"type"`
}

// CompleteStageType defines model for CompleteStage.Type.
type CompleteStageType string

// CompleteStageResponse defines model for completeStageResponse.
type CompleteStageResponse struct {
	Logs    *[]Log   `json:"logs,omitempty"`
	Outputs []Output `json:"outputs"`
}

// Error defines model for error.
type Error struct {
	Code    string `json:"code"`
	Message string `json:"message"`
}

// ErrorStage defines model for errorStage.
type ErrorStage struct {
	Code     string                  `json:"code"`
	Message  string                  `json:"message"`
	Metadata *map[string]interface{} `json:"metadata,omitempty"`
	Retry    *RetryStrategy          `json:"retry,omitempty"`
}

// Input defines model for input.
type Input struct {
	Name  string      `json:"name"`
	Value interface{} `json:"value"`
}

// Log defines model for log.
type Log struct {
	Level   LogLevel `json:"level"`
	Message string   `json:"message"`
}

// LogLevel defines model for Log.Level.
type LogLevel string

// Output defines model for output.
type Output struct {
	Mimetype OutputMimetype `json:"mimetype"`
	Name     string         `json:"name"`

	// Value Any type of value
	Value interface{} `json:"value"`
}

// OutputMimetype defines model for Output.Mimetype.
type OutputMimetype string

// PreviousStageResult defines model for previousStageResult.
type PreviousStageResult struct {
	Name  string      `json:"name"`
	Value interface{} `json:"value"`
}

// RetryStrategy defines model for retryStrategy.
type RetryStrategy struct {
	// BackoffMultiplier Backoff Multiplier to increment after each failure attempt
	BackoffMultiplier int `json:"backoffMultiplier"`

	// FirstBackoffWait First time to backoff wait in milliseconds
	FirstBackoffWait int `json:"firstBackoffWait"`
	Times            int `json:"times"`
}

// Spec defines model for spec.
type Spec struct {
	Complete CompleteStage `json:"complete"`
	Stages   []Stage       `json:"stages"`
}

// Stage defines model for stage.
type Stage struct {
	Inputs []string  `json:"inputs"`
	Name   string    `json:"name"`
	Type   StageType `json:"type"`
}

// StageType defines model for Stage.Type.
type StageType string

// StageRequest defines model for stageRequest.
type StageRequest struct {
	CorrelationID  string                `json:"correlationID"`
	Inputs         *[]Input              `json:"inputs,omitempty"`
	JobKey         string                `json:"jobKey"`
	PreviousStages []PreviousStageResult `json:"previousStages"`
	TransactionID  string                `json:"transactionID"`
}

// StageResponse defines model for stageResponse.
type StageResponse struct {
	Logs  *[]Log      `json:"logs,omitempty"`
	Value interface{} `json:"value"`
}

// PostInitJSONBody defines parameters for PostInit.
type PostInitJSONBody struct {
	// Config Full user defined config to configure spark on initialise
	Config *string `json:"config,omitempty"`
}

// PostCompleteNameJSONRequestBody defines body for PostCompleteName for application/json ContentType.
type PostCompleteNameJSONRequestBody = StageRequest

// PostInitJSONRequestBody defines body for PostInit for application/json ContentType.
type PostInitJSONRequestBody PostInitJSONBody

// PostStagesNameJSONRequestBody defines body for PostStagesName for application/json ContentType.
type PostStagesNameJSONRequestBody = StageRequest

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// PostCompleteName request with any body
	PostCompleteNameWithBody(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostCompleteName(ctx context.Context, name string, body PostCompleteNameJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostInit request with any body
	PostInitWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostInit(ctx context.Context, body PostInitJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSpec request
	GetSpec(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostStagesName request with any body
	PostStagesNameWithBody(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostStagesName(ctx context.Context, name string, body PostStagesNameJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) PostCompleteNameWithBody(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCompleteNameRequestWithBody(c.Server, name, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCompleteName(ctx context.Context, name string, body PostCompleteNameJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCompleteNameRequest(c.Server, name, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostInitWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostInitRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostInit(ctx context.Context, body PostInitJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostInitRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSpec(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSpecRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostStagesNameWithBody(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostStagesNameRequestWithBody(c.Server, name, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostStagesName(ctx context.Context, name string, body PostStagesNameJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostStagesNameRequest(c.Server, name, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewPostCompleteNameRequest calls the generic PostCompleteName builder with application/json body
func NewPostCompleteNameRequest(server string, name string, body PostCompleteNameJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostCompleteNameRequestWithBody(server, name, "application/json", bodyReader)
}

// NewPostCompleteNameRequestWithBody generates requests for PostCompleteName with any type of body
func NewPostCompleteNameRequestWithBody(server string, name string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/complete/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostInitRequest calls the generic PostInit builder with application/json body
func NewPostInitRequest(server string, body PostInitJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostInitRequestWithBody(server, "application/json", bodyReader)
}

// NewPostInitRequestWithBody generates requests for PostInit with any type of body
func NewPostInitRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/init")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSpecRequest generates requests for GetSpec
func NewGetSpecRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/spec")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostStagesNameRequest calls the generic PostStagesName builder with application/json body
func NewPostStagesNameRequest(server string, name string, body PostStagesNameJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostStagesNameRequestWithBody(server, name, "application/json", bodyReader)
}

// NewPostStagesNameRequestWithBody generates requests for PostStagesName with any type of body
func NewPostStagesNameRequestWithBody(server string, name string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stages/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// PostCompleteName request with any body
	PostCompleteNameWithBodyWithResponse(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCompleteNameResponse, error)

	PostCompleteNameWithResponse(ctx context.Context, name string, body PostCompleteNameJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCompleteNameResponse, error)

	// PostInit request with any body
	PostInitWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostInitResponse, error)

	PostInitWithResponse(ctx context.Context, body PostInitJSONRequestBody, reqEditors ...RequestEditorFn) (*PostInitResponse, error)

	// GetSpec request
	GetSpecWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSpecResponse, error)

	// PostStagesName request with any body
	PostStagesNameWithBodyWithResponse(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostStagesNameResponse, error)

	PostStagesNameWithResponse(ctx context.Context, name string, body PostStagesNameJSONRequestBody, reqEditors ...RequestEditorFn) (*PostStagesNameResponse, error)
}

type PostCompleteNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CompleteStageResponse
	JSON500      *ErrorStage
}

// Status returns HTTPResponse.Status
func (r PostCompleteNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostCompleteNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostInitResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r PostInitResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostInitResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSpecResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Spec
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetSpecResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSpecResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostStagesNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StageResponse
	JSON500      *ErrorStage
}

// Status returns HTTPResponse.Status
func (r PostStagesNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostStagesNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// PostCompleteNameWithBodyWithResponse request with arbitrary body returning *PostCompleteNameResponse
func (c *ClientWithResponses) PostCompleteNameWithBodyWithResponse(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCompleteNameResponse, error) {
	rsp, err := c.PostCompleteNameWithBody(ctx, name, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCompleteNameResponse(rsp)
}

func (c *ClientWithResponses) PostCompleteNameWithResponse(ctx context.Context, name string, body PostCompleteNameJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCompleteNameResponse, error) {
	rsp, err := c.PostCompleteName(ctx, name, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCompleteNameResponse(rsp)
}

// PostInitWithBodyWithResponse request with arbitrary body returning *PostInitResponse
func (c *ClientWithResponses) PostInitWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostInitResponse, error) {
	rsp, err := c.PostInitWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostInitResponse(rsp)
}

func (c *ClientWithResponses) PostInitWithResponse(ctx context.Context, body PostInitJSONRequestBody, reqEditors ...RequestEditorFn) (*PostInitResponse, error) {
	rsp, err := c.PostInit(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostInitResponse(rsp)
}

// GetSpecWithResponse request returning *GetSpecResponse
func (c *ClientWithResponses) GetSpecWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSpecResponse, error) {
	rsp, err := c.GetSpec(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSpecResponse(rsp)
}

// PostStagesNameWithBodyWithResponse request with arbitrary body returning *PostStagesNameResponse
func (c *ClientWithResponses) PostStagesNameWithBodyWithResponse(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostStagesNameResponse, error) {
	rsp, err := c.PostStagesNameWithBody(ctx, name, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostStagesNameResponse(rsp)
}

func (c *ClientWithResponses) PostStagesNameWithResponse(ctx context.Context, name string, body PostStagesNameJSONRequestBody, reqEditors ...RequestEditorFn) (*PostStagesNameResponse, error) {
	rsp, err := c.PostStagesName(ctx, name, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostStagesNameResponse(rsp)
}

// ParsePostCompleteNameResponse parses an HTTP response from a PostCompleteNameWithResponse call
func ParsePostCompleteNameResponse(rsp *http.Response) (*PostCompleteNameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostCompleteNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CompleteStageResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorStage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostInitResponse parses an HTTP response from a PostInitWithResponse call
func ParsePostInitResponse(rsp *http.Response) (*PostInitResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostInitResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSpecResponse parses an HTTP response from a GetSpecWithResponse call
func ParseGetSpecResponse(rsp *http.Response) (*GetSpecResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSpecResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Spec
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostStagesNameResponse parses an HTTP response from a PostStagesNameWithResponse call
func ParsePostStagesNameResponse(rsp *http.Response) (*PostStagesNameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostStagesNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StageResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorStage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (POST /complete/{name})
	PostCompleteName(ctx echo.Context, name string) error

	// (POST /init)
	PostInit(ctx echo.Context) error

	// (GET /spec)
	GetSpec(ctx echo.Context) error

	// (POST /stages/{name})
	PostStagesName(ctx echo.Context, name string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// PostCompleteName converts echo context to params.
func (w *ServerInterfaceWrapper) PostCompleteName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithLocation("simple", false, "name", runtime.ParamLocationPath, ctx.Param("name"), &name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostCompleteName(ctx, name)
	return err
}

// PostInit converts echo context to params.
func (w *ServerInterfaceWrapper) PostInit(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostInit(ctx)
	return err
}

// GetSpec converts echo context to params.
func (w *ServerInterfaceWrapper) GetSpec(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSpec(ctx)
	return err
}

// PostStagesName converts echo context to params.
func (w *ServerInterfaceWrapper) PostStagesName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithLocation("simple", false, "name", runtime.ParamLocationPath, ctx.Param("name"), &name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostStagesName(ctx, name)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.POST(baseURL+"/complete/:name", wrapper.PostCompleteName)
	router.POST(baseURL+"/init", wrapper.PostInit)
	router.GET(baseURL+"/spec", wrapper.GetSpec)
	router.POST(baseURL+"/stages/:name", wrapper.PostStagesName)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+xXTXPbNhD9Kxi0R9Zy0+lFt3y0HbVx47E99SHjA0QuJTgkgABLxxoP/3sHH6RIArTk",
	"1k5z6E0CF4u37+0uFg80l7WSAgQaunygJt9CzdxP+6EChEtkG7ALSksFGjm4z1yoxu/hCLX7gRwroEv6",
	"J6uBZhR3yv4zqLnY0Dbrv6/81t6Cac121kDYjcc4cgsPFERT0+XHHiq92R9yZW2ivW1GNXxuuIbCbkRv",
	"JPw5IaSBk0vF9CfyNrgnnoreqVzfQo4W0IirCzBKCpPgrJKbMWPfayjpkn632KuwCBIsKjki7b3dG1Mm",
	"G4x0eMyrt9+T2HmaENO5HXAxZoH0USboAK2ljsPPZTGS9639n5C3BmNCznWmZ2HpkKC5d9l5GMD/xWGa",
	"AzuT5FPEzgl5Am6/YRa93YOsYMjGwYa1BFoNqHeHRHZGl6gZwmb3BI68srNMufqISTq2au9Y1YwM/3IL",
	"U3ihGL31zaRrpGDZQolLDe6gGvaIAtbNxhV5KWmXogP3792G583GurfzcG5G5ZyKJZRnFE7Na5h2PaZU",
	"xXOGXIrFrZGCZqMlhHucLMkcAX8wqIHVQzBnvAaSbpjZ0+UtwOSaK3siXdLXYkesLZEl8SbZcQnQh5zI",
	"hQ+epgSBSsMdl43pOnFT/XcZex6w7DumRTNX1H29RnDXLP8ky/KsqZCrioOOWX7jTcjehqAkXOQaahBI",
	"WImgCbB8S0rGq0YDYYhQKxzIETvZg+UCYQPaoi25NhhsrxnHGM2v1oKgzSqUJMAnXxhHwgWpeVVxA7kU",
	"hRmc7jd1GJzj1OnW62jauHILsen0qg9mEfoswe9AxAurDenFSahnFOSpqyPMJAd69XjMsu7sj+MvdNPt",
	"GzXxeFSY0GE6q9Ts5MeeSwU5L0PvSAb+7U+GHuLLjIWz06DxvedzAwZTiaE1VI7U1bvxONR/IKt3qegS",
	"zD6WGv6+PobeW7n+A3ZDML/LNbFLCRSjFns8mlRnbueaZQokaiYMy2PirvYfksRN1A3BZhMlpgdEgUaD",
	"UifxfAp8xYfAkXdVdEkdmubbNsxMUZe/hjW51kwp0MRXxLmW9zvy+nw1aOuPW92BNt7bjyenJ6duBFIg",
	"mOJ0SX9ySxlVDLeOpb5ZLh5sbbaOWGkSN9BbVlVQ2NsH7iFvEAgjxp5uSOeDmFC/VhifBIXNQ2mwe+qE",
	"LqOYZjUgaEOXH21/o0uHqWsRy65T7IlG3UAWXtNOlElG3nhjMPhGFjvfFgSCcKFEg13/MD/qMujSsm29",
	"+F5ZR+Cr09NnOyv95nVnTrSYeTi2Gf35GfEM3nEJEIOnDRSBmgUXfnpJ59BKcOTMjioEt+DT54R8ENWO",
	"5D69pMiBSGEzSWOjTpLJZN3Qfy739PIQJd8kJq6mqkhjQJMCSi6gIN7SVoD/ZUc+F4IFzPvQ6PCB73yn",
	"2mfUE+LEevUIgf5OM02egzFlU72I9CnV/fO7j5aLjeegS4BudNtAQv8LwEYLp31p6TXDeYiUUhPcchMc",
	"TpX/DdDOT/QFC9CBT9ab13uIE0LvZaIgHA0J49/X1cGvra0KFhE3pgFDvnDc7gusV8YB/Dd9fr69+/v8",
	"/+Z++Kz5pv5t9fK2/TsAAP//OKB0j8kWAAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
